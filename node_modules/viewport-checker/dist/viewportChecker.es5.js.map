{"version":3,"file":"viewportChecker.es5.js","sources":["../src/viewportchecker.ts"],"sourcesContent":["declare global {\n    interface Window {\n        _VP_CHECKERS?: ViewportChecker[];\n    }\n}\n\nexport type Action = 'add' | 'remove';\n\nexport interface ViewportCheckerOptions {\n    classToAdd: string;\n    classToRemove: string;\n    classToAddForFullView: string;\n    removeClassAfterAnimation: boolean;\n    offset: number | string,\n    repeat: boolean,\n    invertBottomOffset: boolean,\n    callbackFunction: ((elem: Element, action: Action) => void);\n    scrollHorizontal: boolean;\n    scrollBox: Window | string;\n}\n\nexport type ViewportCheckerAttributeOptions = Partial<Pick<ViewportCheckerOptions, 'classToAdd' | 'classToRemove' | 'classToAddForFullView' | 'removeClassAfterAnimation' | 'offset' | 'repeat' | 'scrollHorizontal' | 'invertBottomOffset'>>;\n\ninterface BoxSize {\n    height: number;\n    width: number;\n}\n\nexport default class ViewportChecker implements EventListenerObject {\n\n    /**\n     * Index on which the instance if registered in the global register\n     */\n    private _registerIndex: number | undefined;\n\n    /**\n     * User provided options, merged with default options\n     */\n    readonly options: ViewportCheckerOptions;\n\n    /**\n     * Cached list of element to use.\n     */\n    private elements: NodeListOf<HTMLElement> | undefined;\n\n    /**\n     * Size of the provided scrollBox\n     */\n    private boxSize: BoxSize = {\n        height: 0,\n        width: 0\n    };\n\n    constructor(readonly query: string, userOptions?: Partial<ViewportCheckerOptions>) {\n        // Merge user options with default options\n        this.options = {\n            classToAdd: 'visible',\n            classToRemove: 'invisible',\n            classToAddForFullView: 'full-visible',\n            removeClassAfterAnimation: false,\n            offset: 100,\n            repeat: false,\n            invertBottomOffset: true,\n            callbackFunction: () => void 0,\n            scrollHorizontal: false,\n            scrollBox: window,\n            ...userOptions\n        };\n    }\n\n    handleEvent(evt: Event): void {\n        switch (evt.type) {\n            case 'scroll':\n                this.check();\n                break;\n            case 'resize':\n                this.recalculateBoxsize();\n                this.check();\n                break;\n        }\n    }\n\n    /**\n     * Query the document for elements and save them under elements\n     */\n    attach() {\n        // Get elements and calculate box size\n        this.elements = document.querySelectorAll<HTMLElement>(this.query);\n        this.recalculateBoxsize();\n\n        // Register on global event listeners\n        this._registerIndex = registerGlobalInstance(this);\n\n        if (!(this.options.scrollBox instanceof Window)) {\n            const box = this.resolveScrollBox();\n            box.addEventListener('scroll', this);\n        }\n\n        // Perform initial check\n        this.check();\n    }\n\n    /**\n     * Detach checker from elements.\n     */\n    detach() {\n        if (this._registerIndex) {\n            unregisterGlobalInstance(this._registerIndex);\n            this._registerIndex = undefined;\n\n            if (!(this.options.scrollBox instanceof Window)) {\n                const box = this.resolveScrollBox();\n                box.removeEventListener('scroll', this);\n            }\n        }\n    }\n\n    /**\n     * Returns a reference to the defined scrollbox\n     */\n    private resolveScrollBox(): Window | HTMLElement {\n        if (this.options.scrollBox instanceof Window) {\n            return this.options.scrollBox;\n        }\n        const box = document.querySelector<HTMLElement>(this.options.scrollBox);\n        if (!box) {\n            throw new Error(`${this.options.scrollBox} does not resolve to an existing DOM Element`);\n        }\n        return box;\n    }\n\n    /**\n     * Recalculate and set the box size\n     */\n    recalculateBoxsize() {\n        this.boxSize = this.getBoxSize();\n    }\n\n    /**\n     * Main method which checks the elements and applies the correct actions to it\n     */\n    check() {\n        let viewportStart = 0;\n        let viewportEnd = 0;\n\n        // Set some vars to check with\n        if (!this.options.scrollHorizontal) {\n            viewportStart = Math.max(\n                document.body.scrollTop,\n                document.documentElement.scrollTop,\n                window.scrollY\n            );\n            viewportEnd = (viewportStart + this.boxSize.height);\n        }\n        else {\n            viewportStart = Math.max(\n                document.body.scrollLeft,\n                document.documentElement.scrollLeft,\n                window.scrollX\n            );\n            viewportEnd = (viewportStart + this.boxSize.width);\n        }\n\n        // Loop through all given dom elements\n        this.elements?.forEach(($obj: HTMLElement) => {\n            const objOptions: ViewportCheckerOptions = { ...this.options };\n\n            const attrOptionMap: { [key in keyof ViewportCheckerAttributeOptions]-?: string } = {\n                classToAdd: 'vpAddClass',\n                classToRemove: 'vpRemoveClass',\n                classToAddForFullView: 'vpAddClassFullView',\n                removeClassAfterAnimation: 'vpKeepAddClass',\n                offset: 'vpOffset',\n                repeat: 'vpRepeat',\n                scrollHorizontal: 'vpScrollHorizontal',\n                invertBottomOffset: 'vpInvertBottomOffset'\n            };\n\n            //  Get any individual attribution data and override original\n            // options.\n            for (const opt in attrOptionMap) {\n                const dataKey = attrOptionMap[opt as keyof typeof attrOptionMap];\n                const val = $obj.dataset[dataKey];\n                if (val) { (objOptions as any)[opt] = val; };\n            }\n\n            // If class already exists; quit\n            if ($obj.dataset.vpAnimated && !objOptions.repeat) {\n                return;\n            }\n\n            // Check if the offset is percentage based\n            let objOffset: number;\n            if (typeof objOptions.offset === 'string') {\n                objOffset = objOptions.offset.includes('%') ? (parseInt(objOptions.offset) / 100) * this.boxSize.height : parseInt(objOptions.offset);\n            }\n            else if (typeof objOptions.offset === 'number') {\n                objOffset = objOptions.offset;\n            }\n            else {\n                throw new Error(`Provided objOffet '${objOptions.offset}' can't be parsed. Provide a percentage or absolute number`);\n            }\n\n            // Get the raw start and end positions\n            let rawStart: number = (!objOptions.scrollHorizontal) ? $obj.getBoundingClientRect().top : $obj.getBoundingClientRect().left;\n            let rawEnd: number = rawStart + ((!objOptions.scrollHorizontal) ? $obj.clientHeight : $obj.clientWidth);\n\n            // Add the defined offset\n            let elemStart = Math.round(rawStart) + objOffset;\n            let elemEnd = elemStart + ((!objOptions.scrollHorizontal) ? $obj.clientHeight : $obj.clientWidth);\n\n            if (objOptions.invertBottomOffset) {\n                elemEnd -= (objOffset * 2);\n            }\n\n            // Add class if in viewport\n            if ((elemStart < viewportEnd) && (elemEnd > viewportStart)) {\n                // Remove class\n                $obj.classList.remove(...objOptions.classToRemove.split(' '));\n                $obj.classList.add(...objOptions.classToAdd.split(' '));\n\n                // Do the callback function. Callback wil send the jQuery object as parameter\n                objOptions.callbackFunction($obj, 'add');\n\n                // Check if full element is in view\n                if (rawEnd <= viewportEnd && rawStart >= viewportStart) {\n                    $obj.classList.add(...objOptions.classToAddForFullView.split(' '));\n                }\n                else {\n                    $obj.classList.remove(...objOptions.classToAddForFullView.split(' '));\n                }\n                // Set element as already animated\n                $obj.dataset.vpAnimated = 'true';\n\n                if (objOptions.removeClassAfterAnimation) {\n                    $obj.addEventListener('animationend', () => $obj.classList.remove(...objOptions.classToAdd.split(' ')), {\n                        once: true\n                    });\n                }\n\n                // Remove class if not in viewport and repeat is true\n            } else if (objOptions.repeat && objOptions.classToAdd.split(' ').reduce((exists, cls) => exists || $obj.classList.contains(cls), false)) {\n                $obj.classList.remove(...objOptions.classToAdd.split(' '));\n                $obj.classList.remove(...objOptions.classToAddForFullView.split(' '));\n\n                // Do the callback function.\n                objOptions.callbackFunction($obj, \"remove\");\n\n                // Remove already-animated-flag\n                $obj.dataset.vpAnimated = undefined;\n            }\n        });\n    }\n\n    /**\n     * Get box size of provided scrollBox\n     */\n    private getBoxSize(): BoxSize {\n        const box = this.resolveScrollBox();\n        return (box instanceof Window) ? { height: box.innerHeight, width: box.innerWidth } : { height: box.clientHeight, width: box.clientWidth };\n    }\n}\n\n/**\n * Register the provided instance on the global window object\n * which allows us to reuse the existing event listeners.\n *\n * The returned index can be used to remove the registered instance\n * from the register\n */\nconst registerGlobalInstance = (instance: ViewportChecker): number => {\n    window._VP_CHECKERS = window._VP_CHECKERS || [];\n    return window._VP_CHECKERS.push(instance);\n};\n\n/**\n * Removes an instance from the global register\n */\nconst unregisterGlobalInstance = (index: number): void => {\n    window._VP_CHECKERS = window._VP_CHECKERS || [];\n    if (window._VP_CHECKERS[index]) {\n        window._VP_CHECKERS.splice(index, 1);\n    }\n};\n\n((window: Window, document: Document) => {\n    /**\n     * Check elements of registered instances\n     */\n    const checkElements = () => {\n        (window._VP_CHECKERS || []).forEach(i => i.check());\n    };\n\n    /**\n     * Check elements of registered instances\n     */\n    const recalculateBoxsizes = () => {\n        (window._VP_CHECKERS || []).forEach(i => i.recalculateBoxsize());\n    };\n\n    /**\n     * Binding the correct event listener is still a tricky thing.\n     * People have expierenced sloppy scrolling when both scroll and touch\n     * events are added, but to make sure devices with both scroll and touch\n     * are handled too we always have to add the window.scroll event\n     *\n     * @see  https://github.com/dirkgroenen/jQuery-viewport-checker/issues/25\n     * @see  https://github.com/dirkgroenen/jQuery-viewport-checker/issues/27\n     */\n    if ('ontouchstart' in window || 'onmsgesturechange' in window) {\n        // Device with touchscreen\n        ['touchmove', 'MSPointerMove', 'pointermove'].forEach(e => document.addEventListener(e, checkElements));\n    }\n\n    // Always load on window load\n    window.addEventListener('load', checkElements, { once: true });\n\n    // Handle resizes\n    window.addEventListener('resize', () => {\n        recalculateBoxsizes();\n        checkElements();\n    });\n})(window, document);"],"names":["query","userOptions","this","height","width","options","classToAdd","classToRemove","classToAddForFullView","removeClassAfterAnimation","offset","repeat","invertBottomOffset","callbackFunction","scrollHorizontal","scrollBox","window","ViewportChecker","evt","type","check","recalculateBoxsize","elements","document","querySelectorAll","_registerIndex","registerGlobalInstance","Window","resolveScrollBox","addEventListener","unregisterGlobalInstance","undefined","removeEventListener","box","querySelector","Error","boxSize","getBoxSize","viewportStart","viewportEnd","Math","max","body","scrollLeft","documentElement","scrollX","scrollTop","scrollY","forEach","$obj","objOptions","_this","attrOptionMap","opt","dataKey","val","dataset","vpAnimated","objOffset","includes","parseInt","rawStart","getBoundingClientRect","left","top","rawEnd","clientWidth","clientHeight","elemStart","round","elemEnd","_a","classList","remove","split","_b","add","_c","_d","once","reduce","exists","cls","contains","_e","_f","innerHeight","innerWidth","instance","_VP_CHECKERS","push","index","splice","checkElements","i","e"],"mappings":"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"}